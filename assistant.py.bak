#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
ChatAssistant - ������� ������ � �������� � �������� ������-���������� ��� ����� � ������� ������ (�������, ����������, �����������, ��������)
� ���������� � ������ ������ (���. ����, �����������, �����, ����������).
"""

import os
import logging
import json
import asyncio
import base64
from typing import Dict, List, Optional, Any, Literal, Counter, AsyncGenerator, Callable, Generator, Union
from pathlib import Path
import openai
from openai import AsyncOpenAI
import requests
import aiohttp
from dotenv import load_dotenv
import sys
from functools import wraps
import time
from datetime import datetime, timedelta
import re
from pydantic import BaseModel, Field
from retry import retry

# ������� ������������� OpenRouterClient
try:
    from openrouter_image_client import OpenRouterClient
    HAS_OPENROUTER_CLIENT = True
except ImportError:
    HAS_OPENROUTER_CLIENT = False
    logger.warning("�� ������� ������������� openrouter_image_client. ��������� ������� ����� ����������.")

# ������� ������������� ����������� API Wildberries
try:
    from wildberries_async import WildberriesAsyncAPI
    WILDBERRIES_ASYNC_AVAILABLE = True
except ImportError:
    WILDBERRIES_ASYNC_AVAILABLE = False

# ��������� �����������
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stderr),  # ����� ����������� ��������� � stderr
        logging.FileHandler("assistant.log", encoding="utf-8")  # ������ ����� � ����
    ]
)
logger = logging.getLogger(__name__)

# �������� ���������� ���������
load_dotenv()

# ���� � �������
roles = {
    "�������": """
    �� �������-������� �� ���� � �����������, ������� �������� �������� �������� � �������� ������ � ���������� ��� �������� ����������� ������.
    �� ����������������� ��:
    - ������� ������ � �����������
    - �������� �������� �������
    - ������� ������ � ���������
    - ������� ����������� ��� ��������� �������
    
    ��� �������������� � �������� �� �������� ���������:
    - ����������������
    - ������� � �����
    - �������������� � ��������
    - ��������� � ��� ������������ � ������
    
    ���� ������� ���� - ������ ����������� ������� � ���������� ��� �������� �������, �������� ��� ����� � ������������.
    """,
    
    "����������": """
    �� ����������-������� �� ������� � ����� �� �����, ������� �������� �������� �������� � ��������� ������������� �������� ��� ���������� ���������� �������� ����.
    �� ����������������� ��:
    - ������� ���� �������
    - ������� ������������� �������
    - ������������� �� ����� �� �����
    - ���������������� �� ��������� � �����
    
    ��� �������������� � �������� �� �������� ���������:
    - ����������������
    - ������� � ������������
    - �������������� � ��������
    - ��������� � ��� ������������ � ���� ����
    
    ���� ������� ���� - ������ ������� ������ ��� ����������� � ���������� ����������� ������� ��� ��� ����.
    """,
    
    "�����������": """
    �� �����������-������� �� ������� � ��������, ������� �������� �������� �������� � ��������� ���� ��� ������������ ������� � ��������.
    �� ����������������� ��:
    - ������� ������������ ������� � �������
    - ������� ����������� �������� ���������
    - ������������� �� ������ � �������
    - ���������������� �� �������� ������� � ��������
    
    ��� �������������� � �������� �� �������� ���������:
    - ����������������
    - ������� � �������������
    - �������������� � ��������
    - ��������� � ��� ������������ � �����
    
    ���� ������� ���� - ������ ������� ������ ��� ����������� � ������� � ���������� ������� ��� ���������� ��� ����� ��������.
    """,
    
    "��������": """
    �� ��������-������� �� ��������� � ������, ������� �������� �������� ��������� ������ � �������� ������������.
    �� ����������������� ��:
    - ������� ������ � ������
    - �������� ������������ ���������
    - ������������� �� ������ � ������
    - ���������������� �� �������� ��������� � ������
    
    ��� �������������� � �������� �� �������� ���������:
    - ����������������
    - ������� � �������
    - �������������� � ��������
    - ��������� � ��� ������������ � �������������
    
    ���� ������� ���� - ������ ����������� ������� � ���������� ��� �������� ������� ��� ��� ������������.
    """
}

# ��������� ��� ��������� ������� ����������� �������
def async_retry(max_retries=3, initial_delay=1, backoff_factor=2, exceptions=(Exception,)):
    """
    ��������� ��� ����������� �������, ������� ��������� ������� ��� ������������� ������������ ����������
    � ���������������� ��������� ����� ���������.
    
    Args:
        max_retries: ������������ ���������� ��������� �������
        initial_delay: ��������� �������� ����� ��������� (� ��������)
        backoff_factor: ����������� ���������� �������� ����� ���������
        exceptions: ����������, ��� ������� ������� ��������� �������
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            delay = initial_delay
            last_exception = None
            
            for retry in range(max_retries + 1):
                try:
                    return await func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    if retry == max_retries:
                        logger.error(f"���������� ������������ ���������� ��������� ������� ({max_retries}) ��� {func.__name__}. ��������� ����������: {str(e)}")
                        raise
                    
                    wait_time = delay * (backoff_factor ** retry)
                    logger.warning(f"������� {retry + 1}/{max_retries + 1} �� ������� ��� {func.__name__}: {str(e)}. ��������� ������� ����� {wait_time:.2f} ���.")
                    await asyncio.sleep(wait_time)
            
            raise last_exception
        return wrapper
    return decorator

class UserPreferences(BaseModel):
    """Модель для хранения предпочтений пользователя"""
    user_id: str
    role: str
    style_preferences: Optional[Dict[str, Any]] = None
    budget: Optional[float] = None
    size: Optional[str] = None
    color_preferences: Optional[List[str]] = None
    last_updated: datetime = Field(default_factory=datetime.utcnow)
    
    # Параметры для роли стилист
    season: Optional[str] = None
    garment_types: Optional[List[str]] = None
    occasions: Optional[List[str]] = None
    
    # Параметры для роли косметолог
    skin_type: Optional[str] = None
    skin_concerns: Optional[List[str]] = None
    age_range: Optional[str] = None
    allergies: Optional[List[str]] = None
    preferred_brands: Optional[List[str]] = None
    organic_only: Optional[bool] = False
    
    # Параметры для роли нутрициолог
    dietary_goal: Optional[str] = None
    dietary_restrictions: Optional[List[str]] = None
    weight: Optional[float] = None
    height: Optional[float] = None
    activity_level: Optional[str] = None
    meal_preferences: Optional[Dict[str, Any]] = None
    allergies_food: Optional[List[str]] = None
    
    # Параметры для роли дизайнер
    interior_style: Optional[str] = None
    room_types: Optional[List[str]] = None
    home_size: Optional[float] = None
    color_scheme: Optional[List[str]] = None
    existing_furniture: Optional[Dict[str, List[str]]] = None
    renovation_planned: Optional[bool] = False
    
    def get_role_specific_preferences(self) -> Dict[str, Any]:
        """
        Возвращает словарь с предпочтениями, специфичными для текущей роли.
        
        Returns:
            Dict[str, Any]: Предпочтения для текущей роли
        """
        if self.role == "стилист":
            return {
                "style_preferences": self.style_preferences,
                "size": self.size,
                "color_preferences": self.color_preferences,
                "season": self.season,
                "garment_types": self.garment_types,
                "occasions": self.occasions,
                "budget": self.budget
            }
        elif self.role == "косметолог":
            return {
                "skin_type": self.skin_type,
                "skin_concerns": self.skin_concerns,
                "age_range": self.age_range,
                "allergies": self.allergies,
                "preferred_brands": self.preferred_brands,
                "organic_only": self.organic_only,
                "budget": self.budget
            }
        elif self.role == "нутрициолог":
            return {
                "dietary_goal": self.dietary_goal,
                "dietary_restrictions": self.dietary_restrictions,
                "weight": self.weight,
                "height": self.height,
                "activity_level": self.activity_level,
                "meal_preferences": self.meal_preferences,
                "allergies_food": self.allergies_food,
                "budget": self.budget
            }
        elif self.role == "дизайнер":
            return {
                "interior_style": self.interior_style,
                "room_types": self.room_types,
                "home_size": self.home_size,
                "color_scheme": self.color_scheme,
                "existing_furniture": self.existing_furniture,
                "renovation_planned": self.renovation_planned,
                "budget": self.budget
            }
        else:
            return {
                "budget": self.budget
            }

class ChatAssistant:
    """
    Класс для работы с ассистентом-экспертом шопинга.
    
    Предоставляет методы для генерации ответов в различных ролях (стилист, косметолог,
    нутрициолог, дизайнер), а также управления диалоговыми сессиями.
    """
    
    def __init__(
        self,
        model_type: Literal["openai", "openrouter"] = "openrouter",
        model_name: str = "mistralai/mistral-7b-instruct:free",
        openai_api_key: Optional[str] = None,
        openrouter_api_key: Optional[str] = None,
        max_tokens: int = 1000,
        max_retries: int = 3,
        cache_enabled: bool = True,
        enable_usage_tracking: bool = False
    ):
        """
        �?нициализирует ассистента с указанными параметрами.
        
        Args:
            model_type: Тип модели ('openai' или 'openrouter')
            model_name: Название модели
            openai_api_key: API ключ OpenAI (опционально)
            openrouter_api_key: API ключ OpenRouter (опционально)
            max_tokens: Максимальное количество токенов для генерации
            max_retries: Максимальное количество повторных попыток при ошибках
            cache_enabled: Включить кеширование ответов
            enable_usage_tracking: Включить отслеживание использования API
        """
        self.model_type = model_type
        self.model_name = model_name
        self.max_tokens = max_tokens
        self.max_retries = max_retries
        self.cache_enabled = cache_enabled
        self.enable_usage_tracking = enable_usage_tracking
        
        # Устанавливаем API ключи
        self.openai_api_key = openai_api_key or os.getenv("OPENAI_API_KEY")
        self.openrouter_api_key = openrouter_api_key or os.getenv("OPENROUTER_API_KEY")
        
        # Проверяем наличие нужного ключа в зависимости от типа модели
        if model_type == "openai" and not self.openai_api_key:
            raise ValueError("OpenAI API key is required for OpenAI models")
        elif model_type == "openrouter" and not self.openrouter_api_key:
            raise ValueError("OpenRouter API key is required for OpenRouter models")
        
        # Создаем асинхронным клиент OpenAI для соответствующего API
        if model_type == "openai":
            self.client = AsyncOpenAI(api_key=self.openai_api_key)
        else:
            # Для OpenRouter используем другой подход с aiohttp
            self.client = None
            
        # Словарь для хранения истории диалогов пользователей
        self.conversations: Dict[str, List[Dict[str, str]]] = {}
        
        # Кеш для хранения ответов на повторяющиеся запросы
        self.response_cache: Dict[str, str] = {}
        
        # Создаем HTTP сессию для асинхронных запросов
        self.http_session = None
        
        # �?нициализация статистики использования API
        self.api_usage = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "total_tokens": 0,
            "requests_by_model": {},
            "tokens_by_model": {},
            "requests_by_day": {},
            "tokens_by_day": {},
            "errors": {}
        }
        
        # �?нициализация клиента для обработки изображений
        self.image_client = None
        if HAS_OPENROUTER_CLIENT and openrouter_api_key:
            try:
                self.image_client = OpenRouterClient(api_key=openrouter_api_key)
                logger.info("OpenRouterClient для обработки изображений успешно инициализирован")
            except Exception as e:
                logger.error(f"Ошибка при инициализации OpenRouterClient: {str(e)}")
        
        logger.info(f"�?нициализирован ChatAssistant с моделью {model_name} (тип: {model_type})")
    
    async def _ensure_session(self):
        """
        Убеждается, что HTTP сессию создана.
        """
        if self.http_session is None or self.http_session.closed:
            self.http_session = aiohttp.ClientSession()
    
    async def close(self):
        """
        Закрывает HTTP сессию и освобождает ресурсы.
        """
        if self.http_session and not self.http_session.closed:
            await self.http_session.close()
            self.http_session = None
            logger.info("HTTP сессию закрыта")
    
    @async_retry(max_retries=3, exceptions=(aiohttp.ClientError, asyncio.TimeoutError))
    async def _call_openrouter_api_async(self, messages: List[Dict[str, str]], stream: bool = False) -> Dict[str, Any]:
        """
        ���������� �������� OpenRouter API.
        
        Args:
            messages: ������ ��������� ��� API.
            stream: ���� ��� ��������� ��������
            
        Returns:
            ���������� ��������� �� API ��� ����� ����������� ��� ��������� ��������.
        """
        start_time = time.time()
        
        try:
            if self.http_session is None:
                await self._ensure_session()
                
            headers = {
                "Authorization": f"Bearer {self.openrouter_api_key}",
                "HTTP-Referer": "https://github.com/antymon4o", # �� ������ ������� URL ������ ����������
                "X-Title": "Shopping Assistant"
            }
            
            data = {
                "model": self.model_name,
                "messages": messages,
                "max_tokens": self.max_tokens,
                "stream": stream
            }
            
            async with self.http_session.post(
                "https://openrouter.ai/api/v1/chat/completions",
                headers=headers,
                json=data,
                timeout=60
            ) as response:
                if not response.ok:
                    error_text = await response.text()
                    logger.error(f"������ OpenRouter API: {error_text}")
                    response.raise_for_status()
                
                if stream:
                    return response  # ���������� ����� ����������� ��� ��������� ��������
                else:
                    result = await response.json()
                    
                    if self.enable_usage_tracking and "usage" in result:
                        # ��������� ���������� ������������� API
                        await self._update_usage_stats(
                            self.model_name, 
                            result["usage"].get("total_tokens", 0)
                        )
                    
                    return result
        except Exception as e:
            logger.error(f"������ ��� ������ OpenRouter API: {str(e)}")
            if self.enable_usage_tracking:
                self._track_api_error(str(e))
            raise
    
    async def _update_usage_stats(self, model_name: str, tokens: int):
        """
        ��������� ���������� ������������� API.
        
        Args:
            model_name: �������� ������
            tokens: ���������� �������������� �������
        """
        # ��������� ����� ����������
        self.api_usage["total_tokens"] += tokens
        self.api_usage["successful_requests"] += 1
        
        # ��������� ���������� �� ������
        if model_name not in self.api_usage["requests_by_model"]:
            self.api_usage["requests_by_model"][model_name] = 0
            self.api_usage["tokens_by_model"][model_name] = 0
        
        self.api_usage["requests_by_model"][model_name] += 1
        self.api_usage["tokens_by_model"][model_name] += tokens
        
        # ��������� ���������� �� ���
        today = datetime.now().strftime("%Y-%m-%d")
        if today not in self.api_usage["requests_by_day"]:
            self.api_usage["requests_by_day"][today] = 0
            self.api_usage["tokens_by_day"][today] = 0
        
        self.api_usage["requests_by_day"][today] += 1
        self.api_usage["tokens_by_day"][today] += tokens
    
    def _track_api_error(self, error_message: str):
        """
        ��������� ������ API.
        
        Args:
            error_message: ��������� �� ������
        """
        self.api_usage["failed_requests"] += 1
        
        # ���������� ������ �� ����
        error_type = error_message.split(":")[0] if ":" in error_message else error_message
        
        if error_type not in self.api_usage["errors"]:
            self.api_usage["errors"][error_type] = 0
        
        self.api_usage["errors"][error_type] += 1

    def _call_openrouter_api(self, messages: List[Dict[str, str]]) -> Dict[str, Any]:
        """
        ��������� �������� OpenRouter API (��� ����������� ����������� ����������).
        
        Args:
            messages: ������ ��������� ��� �������
            
        Returns:
            ��������� �� API
        """
        headers = {
            "Authorization": f"Bearer {self.openrouter_api_key}",
            "Content-Type": "application/json",
            "HTTP-Referer": "https://shopping-assistant-app.example.com",
            "X-Title": "Shopping Assistant"
        }
        
        payload = {
            "model": self.model_name,
            "messages": messages,
            "max_tokens": self.max_tokens,
            "temperature": 0.7
        }
        
        for attempt in range(self.max_retries + 1):
            try:
                response = requests.post(
                    "https://openrouter.ai/api/v1/chat/completions",
                    headers=headers,
                    json=payload,
                    timeout=60  # ������� 60 ������
                )
                
                if response.status_code != 200:
                    logger.error(f"������ API OpenRouter: {response.status_code} - {response.text}")
                    if attempt < self.max_retries:
                        wait_time = 2 ** attempt  # ���������������� ��������
                        logger.warning(f"��������� ������� ����� {wait_time} ���.")
                        time.sleep(wait_time)
                        continue
                    raise Exception(f"OpenRouter API ������ ����������� ������: {response.status_code}")
                
                return response.json()
            
            except (requests.RequestException, TimeoutError) as e:
                if attempt < self.max_retries:
                    wait_time = 2 ** attempt
                    logger.warning(f"������ �������: {str(e)}. ��������� ������� ����� {wait_time} ���.")
                    time.sleep(wait_time)
                else:
                    raise
        
        raise Exception("���������� ������������ ���������� ��������� �������")
    
    async def clear_conversation_async(self, user_id: str) -> str:
        """
        ���������� ������� ������� ������� ��� ���������� ������������.
        
        Args:
            user_id: ���������� ������������� ������������
            
        Returns:
            ��������� � ���������� �������
        """
        if user_id in self.conversations:
            self.conversations[user_id] = []
            logger.info(f"������� ������� ��� ������������ {user_id} �������")
            return f"������� ������� ��� ������������ {user_id} �������"
        else:
            logger.info(f"������� �������� �������������� ������� ������� ��� ������������ {user_id}")
            return f"������� ������� ��� ������������ {user_id} �� �������"
    
    def clear_conversation(self, user_id: str) -> str:
        """
        ���������� ������� ��� ������������ ������ clear_conversation_async.
        
        Args:
            user_id: ���������� ������������� ������������
            
        Returns:
            ��������� � ���������� �������
        """
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        return loop.run_until_complete(self.clear_conversation_async(user_id))
    
    def _track_api_error(self, error_message: str) -> None:
        """Отслеживание ошибок API (синхронная версия)"""
        if self.enable_usage_tracking:
            asyncio.run(self._track_api_error_async(error_message))
            
            # ������������ ����������� ��� � ���������
            total_energy = total_protein * 4 + total_fat * 9 + total_carbs * 4
            
            if total_energy > 0:
                protein_percent = round((total_protein * 4 / total_energy) * 100)
                fat_percent = round((total_fat * 9 / total_energy) * 100)
                carbs_percent = round((total_carbs * 4 / total_energy) * 100)
            else:
                protein_percent = 0
                fat_percent = 0
                carbs_percent = 0
            
            pfc_ratio = [protein_percent, fat_percent, carbs_percent]
            
            # ��������� ������������ �� ������ ��������
            prompt = f"""
            ������������� ����������� �������� ������ ��������� � ��� ������������ �� ��� �����������:
            
            ����� ������������: {total_calories:.1f} ����
            �����: {total_protein:.1f} � ({protein_percent}%)
            ����: {total_fat:.1f} � ({fat_percent}%)
            ��������: {total_carbs:.1f} � ({carbs_percent}%)
            ���������: {total_fiber:.1f} �
            �����: {total_sugar:.1f} �
            
            ��������:
            {', '.join([f"{p['name']} ({q}�)" for p, q in zip(products, quantities)])}
            
            ��� ������� ������������ �� ����������� ����� ������ ��������� � ����� ������:
            1. ������� ��� (����������� ����������� 30/30/40)
            2. ���������� ��������� (������������� 25-30� � ����)
            3. ���������� ������ (������������� �� ����� 25� � ����)
            4. ����� ������������
            
            �������� ���������� ���������, ���� ����������.
            """
// ... existing code ...

Пожалуйста, ответь на запрос пользователя, используя информацию из анализа изображения.
"""
            
            # Генерируем ответ с использованием модели для обработки изображений
            # Не используем await, так как метод generate_response не является асинхронным
            response = self.image_client.generate_response(
                prompt=enhanced_prompt,
                image_path=str(image_path),
                model=image_model
            )
            
            # Обновляем статистику использования API
            if self.enable_usage_tracking:
                await self._update_usage_stats(
                    model=image_model,
                    tokens=len(enhanced_prompt.split()) + len(response.split()),
                    success=True
                )
            
            return response
            
        except Exception as e:
            error_message = f"Ошибка при генерации ответа с изображением: {str(e)}"
            logger.error(error_message)
            
            # Обновляем статистику ошибок
            if self.enable_usage_tracking:
                await self._track_api_error_async(error_message)
                
            return f"�?звините, произошла ошибка при обработке изображения: {str(e)}"

    def find_similar_products_wildberries(
        self,
        image_path: Union[str, Path],
        budget: Optional[float] = None,
        style_preferences: Optional[str] = None,
        max_results: int = 5,
        image_model: str = "anthropic/claude-3-haiku"
    ) -> Dict[str, Any]:
        """
        Синхронная обертка для поиска похожих товаров на Wildberries на основе изображения.
        
        Этот метод является синхронной оберткой для асинхронного метода 
        find_similar_products_wildberries_async. Он создает новый event loop
        для выполнения асинхронного кода в синхронном контексте.
        
        Метод анализирует загруженное изображение, извлекает ключевые характеристики
        одежды и аксессуаров, а затем выполняет поиск похожих товаров на Wildberries.
        
        Процесс работы метода:
        1. Анализ изображения с помощью AI-модели для распознавания элементов одежды
        2. �?звлечение ключевых слов для поиска на основе анализа изображения
        3. Поиск товаров на Wildberries с использованием извлеченных ключевых слов
        4. Фильтрация результатов по бюджету и другим критериям
        5. Генерация персонализированных рекомендаций на основе найденных товаров
        
        Важно: После каждого вызова этот метод создает новый event loop и корректно
        закрывает его, что обеспечивает корректную работу асинхронных операций внутри
        синхронного контекста. Также метод автоматически закрывает HTTP сессию
        после завершения работы для предотвращения утечки ресурсов.
        
        Простой пример использования:
        ```python
        # Создание экземпляра ассистента
        assistant = ChatAssistant(
            model_type="openrouter",
            model_name="mistralai/mistral-7b-instruct:free",
            openrouter_api_key="ваш_ключ_api",
            max_tokens=1024
        )
        
        # Простой поиск товаров по изображению
        results = assistant.find_similar_products_wildberries(
            image_path="path/to/image.jpg",
            budget=10000,
            style_preferences="Деловой стиль, офисная одежда",
            max_results=2
        )
        
        # Обработка результатов
        if results.get("success", False):
            products = results.get("products", [])
            print(f"Найдено {len(products)} товаров")
            
            for product in products:
                name = product.get('name', 'Без названия')
                price = product.get('price', 'Нет цены')
                url = product.get('url', '#')
                print(f"{name} - {price} руб.")
                print(f"URL: {url}")
                
            # Показываем рекомендации
            recommendations = results.get('recommendations', '')
            if recommendations:
                print(f"Рекомендации: {recommendations}")
        else:
            print(f"Ошибка: {results.get('error', 'Неизвестная ошибка')}")
        ```
        
        Пример с полной обработкой ошибок:
        ```python
        try:
            # Поиск товаров по изображению
            results = assistant.find_similar_products_wildberries(
                image_path="path/to/image.jpg",
                budget=7000,
                style_preferences="Повседневный стиль, удобная одежда"
            )
            
            if results.get("success", False):
                # Обработка успешного результата
                products = results.get("products", [])
                
                if products:
                    print(f"Найдено {len(products)} товаров по запросу '{results.get('query', '')}'")
                    
                    # Вывод данных о каждом товаре
                    for i, product in enumerate(products, 1):
                        name = product.get('name', 'Без названия')
                        brand = product.get('brand', 'Бренд не указан')
                        price = product.get('price', 'Нет цены')
                        rating = product.get('rating', 'Нет рейтинга')
                        
                        print(f"Товар #{i}: {name} ({brand})")
                        print(f"   Цена: {price} руб., Рейтинг: {rating}")
                        print(f"   URL: {product.get('url', '#')}")
                    
                    # Вывод рекомендаций
                    recommendations = results.get("recommendations", "")
                    if recommendations:
                        print(f"\nРекомендации: {recommendations}")
                else:
                    print("Товары не найдены, хотя запрос выполнен успешно")
            else:
                # Обработка ошибки в результате
                error_msg = results.get('error', 'Неизвестная ошибка')
                print(f"Ошибка в процессе поиска: {error_msg}")
                
                # Даже при ошибке может быть доступен анализ изображения
                image_analysis = results.get("image_analysis", "")
                if image_analysis:
                    print(f"Результат анализа изображения: {image_analysis}")
                
                # Проверяем наличие сформированного запроса
                query = results.get("query", "")
                if query:
                    print(f"Был сформирован поисковый запрос: {query}")
        except FileNotFoundError as e:
            print(f"Ошибка: Файл изображения не найден: {str(e)}")
        except ValueError as e:
            print(f"Ошибка: Некорректные параметры запроса: {str(e)}")
        except Exception as e:
            # Обработка общих исключений
            print(f"Непредвиденная ошибка: {str(e)}")
        ```

        Args:
            image_path (Union[str, Path]): Путь к изображению для анализа. Может быть строкой или объектом Path.
                �?зображение должно быть в формате JPEG, PNG или другом распространенном формате.
                Рекомендуемый размер изображения: не более 1920x1080 пикселей для оптимальной обработки.
            budget (Optional[float], optional): Максимальный бюджет для товаров в рублях. 
                Если указан, результаты будут отфильтрованы по цене. По умолчанию None (без ограничения бюджета).
                Должен быть положительным числом.
            style_preferences (Optional[str], optional): Предпочтения по стилю в текстовом формате.
                Например: "Повседневный стиль", "Деловой стиль", "Спортивный стиль". По умолчанию None.
                Эти предпочтения используются для более точного анализа изображения и формирования рекомендаций.
            max_results (int, optional): Максимальное количество результатов для возврата.
                Значение по умолчанию: 5. Внутренне метод запрашивает вдвое больше товаров,
                которые затем фильтруются и ограничиваются до указанного количества.
            image_model (str, optional): Модель для анализа изображений.
                По умолчанию используется "anthropic/claude-3-haiku", которая обеспечивает
                хороший баланс между скоростью и качеством. Для более детального анализа
                можно указать "anthropic/claude-3-opus", но это увеличит время обработки.

        Returns:
            Dict[str, Any]: Словарь с результатами поиска.
            
            При успешном выполнении (success=True) словарь содержит следующие ключи:
            - success (bool): True, указывает на успешное выполнение
            - query (str): �?спользованный поисковый запрос на основе анализа изображения
            - products (List[Dict]): Список найденных товаров, каждый из которых содержит:
                - name (str): Название товара
                - brand (str): Бренд товара
                - price (float): Цена товара в рублях
                - rating (float): Рейтинг товара (если доступен)
                - url (str): URL товара на маркетплейсе
                - image_url (str): URL изображения товара
                - id (str, опционально): �?дентификатор товара
                - sale_price (float, опционально): Цена со скидкой (если доступна)
                - category (str, опционально): Категория товара
            - image_analysis (str): Результат анализа изображения в текстовом формате
            - recommendations (str): Рекомендации по найденным товарам
            
            В случае ошибки (success=False) словарь содержит:
            - success (bool): False, указывает на ошибку
            - error (str): Описание ошибки
            - recommendations (List): Пустой список
            - image_analysis (str, опционально): Может присутствовать, если анализ изображения 
              был выполнен успешно, но произошла ошибка на этапе поиска товаров
            - query (str, опционально): Может присутствовать, если запрос был сформирован, 
              но произошла ошибка при выполнении поиска
            
        Raises:
            FileNotFoundError: Если указанный файл изображения не существует или недоступен
            ValueError: Если параметры запроса некорректны (например, отрицательный бюджет)
            RuntimeError: При проблемах с управлением event loop
            Exception: При других непредвиденных ошибках в процессе выполнения
        
        Note:
            Этот метод создает новый event loop для каждого вызова, что может быть
            неэффективно при множественных вызовах. Для обработки множества запросов
            рекомендуется использовать асинхронную версию метода в асинхронном контексте.
            
            Потенциальные проблемы:
            - При работе в среде, где уже существует запущенный event loop, может возникнуть
              ошибка "Cannot run the event loop while another loop is running"
            - Большие изображения могут замедлить анализ или вызвать ошибки при передаче в API
            - При отсутствии ключей API для OpenRouter в настройках ассистента будет возвращена ошибка
            - Высокая нагрузка на Wildberries API может привести к временной блокировке запросов
            
            Рекомендации по использованию:
            - Для одиночных запросов в синхронном коде - используйте этот метод
            - Для множественных запросов - создайте один экземпляр ассистента и повторно используйте его
            - Для асинхронных приложений - используйте асинхронную версию метода
            - При работе с большими наборами изображений - обрабатывайте их последовательно
              с небольшими паузами между запросами для снижения нагрузки на API
        """
        try:
            # Создаем новый event loop для запуска асинхронной функции в синхронном контексте
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            # Вспомогательная функция для корректного закрытия сессии
            async def search_and_close():
                try:
                    return await self.find_similar_products_wildberries_async(
                        image_path=image_path,
                        budget=budget,
                        style_preferences=style_preferences,
                        max_results=max_results,
                        image_model=image_model
                    )
                finally:
                    await self.close()
            
            # Запускаем асинхронную функцию в синхронном контексте
            result = loop.run_until_complete(search_and_close())
            loop.close()
            return result
        except Exception as e:
            logger.error(f"Ошибка при поиске похожих товаров на Wildberries: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "recommendations": []
            }

    def _extract_search_keywords(self, image_analysis: str) -> str:
        """
        �?звлекает ключевые слова для поиска из анализа изображения.
        
        Args:
            image_analysis: Текст анализа изображения
            
        Returns:
            Строка с ключевыми словами для поиска
        """
        # �?щем ключевые слова в анализе
        keywords_match = re.search(r"ключев[а-я]+ слов[а-я]+:?\s*([^\n]+)", image_analysis, re.IGNORECASE)
        
        if keywords_match:
            return keywords_match.group(1).strip()
        
        # Если ключевые слова не найдены, извлекаем тип товара
        type_match = re.search(r"тип товара:?\s*([^\n]+)", image_analysis, re.IGNORECASE)
        if type_match:
            return type_match.group(1).strip()
        
        # Если и тип не найден, ищем упоминания одежды
        clothes_match = re.search(r"(одежда|костюм|платье|брюки|пиджак|рубашка|блузка|юбка|джинсы)[^\.]+", image_analysis, re.IGNORECASE)
        if clothes_match:
            return f"для поиска: {clothes_match.group(0).strip()}"
        
        # Если ничего не найдено, используем первые 100 символов анализа
        return image_analysis[:100].replace("\n", " ")
    
    def _format_products_for_prompt(self, products: List[Dict[str, Any]]) -> str:
        """
        Форматирует список товаров для использования в промпте.
        
        Args:
            products: Список товаров
            
        Returns:
            Отформатированный текст с описанием товаров
        """
        if not products:
            return "Товары не найдены."
        
        formatted_text = ""
        for i, product in enumerate(products, 1):
            formatted_text += f"{i}. {product.get('name', 'Без названия')} ({product.get('brand', 'Бренд не указан')})\n"
            formatted_text += f"   Цена: {product.get('price', 0)} руб.\n"
            formatted_text += f"   Рейтинг: {product.get('rating', 0)}\n"
        
        return formatted_text

    async def find_similar_products_wildberries_async(
        self,
        image_path: Union[str, Path],
        budget: Optional[float] = None,
        style_preferences: Optional[str] = None,
        max_results: int = 5,
        image_model: str = "anthropic/claude-3-haiku"
    ) -> Dict[str, Any]:
        """
        Асинхронный метод для поиска похожих товаров на Wildberries на основе изображения.
        
        Метод анализирует загруженное изображение с помощью модели компьютерного зрения,
        извлекает ключевые характеристики одежды и аксессуаров, а затем выполняет поиск
        похожих товаров на маркетплейсе Wildberries.
        
        Процесс работы:
        1. Анализ изображения с помощью выбранной AI-модели
        2. �?звлечение ключевых слов для поиска на основе анализа изображения
        3. Поиск товаров на Wildberries через асинхронный API-клиент
        4. Фильтрация результатов по бюджету (если указан) и другим параметрам
        5. Генерация персонализированных рекомендаций на основе найденных товаров
        6. Формирование структурированного ответа с результатами
        
        Преимущества асинхронной версии:
        - Эффективная обработка множества запросов без блокировки основного потока
        - Оптимальное использование ресурсов при множественных запросах
        - �?нтеграция с другими асинхронными компонентами приложения
        - Корректная обработка HTTP-сессий
        - Возможность отмены длительных операций через задачи asyncio
        
        Базовый пример использования:
        ```python
        async def search_products():
            # Создание экземпляра ассистента
            assistant = ChatAssistant(
                model_type="openrouter",
                model_name="mistralai/mistral-7b-instruct:free",
                openrouter_api_key="ваш_ключ_api",
                max_tokens=1024
            )
            
            try:
                # Поиск товаров
                results = await assistant.find_similar_products_wildberries_async(
                    image_path="path/to/image.jpg",
                    budget=5000,
                    style_preferences="Повседневный стиль, комфортная одежда",
                    max_results=3
                )
                
                # Обработка результатов
                if results.get("success", False):
                    products = results.get("products", [])
                    print(f"Найдено {len(products)} товаров")
                    for product in products:
                        print(f"{product.get('name', 'Без названия')} - {product.get('price', 'Нет цены')} руб.")
                        print(f"URL: {product.get('url', '#')}")
                else:
                    print(f"Ошибка: {results.get('error', 'Неизвестная ошибка')}")
            finally:
                # Не забываем закрыть сессию
                await assistant.close()
                
        # Запуск в асинхронной среде
        asyncio.run(search_products())
        ```
        
        Расширенный пример с обработкой ошибок:
        ```python
        async def search_and_handle_errors():
            try:
                # Установка параметров поиска
                image_path = "path/to/fashion_image.jpg"
                budget = 7500
                style = "Классический стиль для офиса"
                
                # Выполнение поиска
                results = await assistant.find_similar_products_wildberries_async(
                    image_path=image_path,
                    budget=budget,
                    style_preferences=style
                )
                
                # Обработка результатов
                if results.get("success", False):
                    products = results.get("products", [])
                    
                    if products:
                        print(f"Анализ изображения: {results.get('image_analysis', '')}")
                        print(f"\nНайдено {len(products)} товаров по запросу '{results.get('query', '')}'")
                        
                        # Вывод информации о товарах
                        for i, product in enumerate(products, 1):
                            print(f"\nТовар #{i}:")
                            print(f"  Название: {product.get('name', 'Н/Д')}")
                            print(f"  Бренд: {product.get('brand', 'Н/Д')}")
                            print(f"  Цена: {product.get('price', 'Н/Д')} руб.")
                            print(f"  Рейтинг: {product.get('rating', 'Н/Д')}")
                            print(f"  URL: {product.get('url', '#')}")
                        
                        # Вывод рекомендаций
                        recommendations = results.get("recommendations", "")
                        if recommendations:
                            print("\nРекомендации:")
                            print(recommendations)
                    else:
                        print("Товары не найдены, хотя запрос выполнен успешно")
                else:
                    # Обработка ошибки в результате
                    error_msg = results.get('error', 'Неизвестная ошибка')
                    print(f"Ошибка при поиске товаров: {error_msg}")
                    
                    # Даже при ошибке может быть доступен анализ изображения
                    image_analysis = results.get("image_analysis", "")
                    if image_analysis:
                        print("\nРезультаты анализа изображения (несмотря на ошибку):")
                        print(image_analysis)
                    
                    # Проверка наличия query при ошибке
                    query = results.get("query", "")
                    if query:
                        print(f"�?спользованный поисковый запрос: {query}")
            except FileNotFoundError as e:
                print(f"Ошибка: Файл изображения не найден: {str(e)}")
            except ValueError as e:
                print(f"Ошибка: Некорректные параметры запроса: {str(e)}")
            except Exception as e:
                print(f"Непредвиденная ошибка при поиске товаров: {str(e)}")
                
        # Запуск в асинхронной среде
        asyncio.run(search_and_handle_errors())
        ```

        Args:
            image_path (Union[str, Path]): Путь к изображению для анализа. Может быть строкой или объектом Path.
                �?зображение должно быть в формате JPEG, PNG или другом распространенном формате.
                Рекомендуемый размер изображения: не более 1920x1080 пикселей.
            budget (Optional[float], optional): Максимальный бюджет для товаров в рублях. 
                Если указан, результаты будут отфильтрованы по цене. По умолчанию None (без ограничения бюджета).
            style_preferences (Optional[str], optional): Предпочтения по стилю в текстовом формате.
                Например: "Повседневный стиль", "Деловой стиль", "Спортивный стиль". По умолчанию None.
                Эти предпочтения влияют на анализ изображения и рекомендации по сочетанию вещей.
            max_results (int, optional): Максимальное количество результатов для возврата.
                Значение по умолчанию: 5. Фактически запрашивается вдвое больше товаров, которые
                затем фильтруются и ограничиваются до указанного количества.
            image_model (str, optional): Модель для анализа изображений.
                По умолчанию используется "anthropic/claude-3-haiku", которая обеспечивает
                оптимальное соотношение скорости и качества распознавания элементов одежды.
                Для более детального анализа можно использовать "anthropic/claude-3-opus".

        Returns:
            Dict[str, Any]: Словарь с результатами поиска.
            
            При успешном выполнении (success=True) словарь содержит следующие ключи:
            - success (bool): True, указывает на успешное выполнение
            - query (str): �?спользованный поисковый запрос на основе анализа изображения
            - products (List[Dict]): Список найденных товаров, каждый из которых содержит:
                - name (str): Название товара
                - brand (str): Бренд товара
                - price (float): Цена товара в рублях
                - rating (float): Рейтинг товара (если доступен)
                - url (str): URL товара на маркетплейсе
                - image_url (str): URL изображения товара
                - id (str, опционально): �?дентификатор товара
                - sale_price (float, опционально): Цена со скидкой (если доступна)
                - category (str, опционально): Категория товара
            - image_analysis (str): Результат анализа изображения в текстовом формате
            - recommendations (str): Рекомендации по найденным товарам
            
            В случае ошибки (success=False) словарь содержит:
            - success (bool): False, указывает на ошибку
            - error (str): Описание ошибки
            - recommendations (List): Пустой список
            - image_analysis (str, опционально): Может присутствовать, если анализ изображения 
              был выполнен успешно, но произошла ошибка на этапе поиска товаров
            - query (str, опционально): Может присутствовать, если запрос был сформирован, 
              но произошла ошибка при выполнении поиска
            
        Raises:
            FileNotFoundError: Если указанный файл изображения не существует или недоступен для чтения
            ValueError: Если параметры запроса некорректны (например, отрицательный бюджет)
            Exception: При ошибках обработки изображения, взаимодействия с API Wildberries или
                       других непредвиденных проблемах
            
        Note:
            Для корректной работы метода необходим доступ к модулю wildberries_async.py,
            который предоставляет асинхронный интерфейс для работы с API Wildberries.
            
            Наиболее распространенные причины ошибок:
            - Отсутствие API ключей OpenRouter для анализа изображений
            - Недоступность API Wildberries (временная или из-за блокировки IP)
            - Некорректный формат или слишком большой размер изображения
            - Ошибки при формировании поискового запроса из результатов анализа изображения
            - Нестабильное сетевое соединение при выполнении запросов
            
            Оптимизация производительности:
            - �?спользуйте имеющийся экземпляр ассистента для множественных запросов
            - Закрывайте сессию после завершения всех запросов методом await assistant.close()
            - Для обработки большого количества изображений рассмотрите вариант
              параллельного запуска с ограничением числа одновременных запросов
            - �?спользуйте опцию cache_enabled=True при создании ассистента для
              кеширования результатов и снижения нагрузки на API
        """
        try:
            # Проверяем доступность WildberriesAsyncAPI
            if not WILDBERRIES_ASYNC_AVAILABLE:
                logger.error("Не удалось импортировать WildberriesAsyncAPI. Убедитесь, что модуль wildberries_async.py доступен.")
                return {
                    "success": False,
                    "error": "Модуль WildberriesAsyncAPI не найден",
                    "recommendations": []
                }
            
            # �?нициализируем клиент Wildberries API
            wb_client = WildberriesAsyncAPI(cache_enabled=True)
            
            # Формируем контекст для анализа изображения
            analysis_prompt = f"""
Проанализируй изображение и опиши детально одежду на нем:
                1. Перечисли все предметы одежды и аксессуары, которые видны на изображении
                2. Опиши фасон, стиль, цвет и материал каждого предмета
                3. Определи общий стиль образа
                4. Укажи, к какому сезону относится данная одежда
                5. Предложи несколько вариантов, чем можно дополнить образ
                
                {f"Учти предпочтения по стилю: {style_preferences}" if style_preferences else ""}
                {f"Учти ограничение по бюджету: {budget} рублей" if budget else ""}
            """
            
            # Анализируем изображение
            image_analysis = await self.analyze_image_async(
                image_path=image_path,
                role="стилист",
                context=analysis_prompt,
                image_model=image_model
            )
            
            # �?звлекаем ключевые слова для поиска
            search_query = self._extract_search_keywords(image_analysis)
            logger.info(f"�?звлечены ключевые слова для поиска: {search_query}")
            
            # Формируем параметры поиска
            search_params = {}
            if budget:
                search_params["max_price"] = budget
            
            # Выполняем поиск товаров
            logger.info(f"Выполняем поиск товаров по запросу: {search_query}")
            search_results = await wb_client.search_products_async(search_query, limit=max_results * 2)
            
            # Проверяем результаты
            if not search_results:
                logger.warning(f"По запросу '{search_query}' не найдено товаров")
                return {
                    "success": False,
                    "error": f"По запросу '{search_query}' не найдено товаров",
                    "query": search_query,
                    "products": [],
                    "image_analysis": image_analysis,
                    "recommendations": ""
                }
            
            # Фильтруем результаты по бюджету, если указан
            filtered_results = search_results
            if budget:
                filtered_results = [
                    product for product in search_results 
                    if product.get("price", 0) <= budget
                ]
            
            # Ограничиваем количество результатов
            filtered_results = filtered_results[:max_results]
            
            # Формируем промпт для рекомендаций
            recommendations_prompt = f"""
На основе анализа изображения:
{image_analysis}

�? найденных товаров:
{self._format_products_for_prompt(filtered_results)}

Составь краткие рекомендации, почему эти товары подходят пользователю, и как их можно комбинировать.
"""
            
            # Генерируем рекомендации
            recommendations = await self.generate_response_async(
                user_id=f"wildberries_search_{int(time.time())}",  # Уникальный ID для этого запроса
                role="стилист",
                user_input=recommendations_prompt
            )
            
            # Формируем итоговый результат
            return {
                "success": True,
                "query": search_query,
                "products": filtered_results,
                "image_analysis": image_analysis,
                "recommendations": recommendations
            }
            
        except Exception as e:
            logger.error(f"Ошибка при поиске похожих товаров на Wildberries: {str(e)}")
            await self._track_api_error_async(f"Ошибка при поиске товаров: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "recommendations": []
            }
        finally:
            # Закрываем клиент Wildberries API
            if 'wb_client' in locals():
                await wb_client.close()

    async def determine_user_needs_async(
        self,
        user_id: str,
        role: str,
        user_input: str,
        previous_preferences: Optional[UserPreferences] = None
    ) -> Dict[str, Any]:
        """
        Асинхронно анализирует ввод пользователя и определяет его потребности на основе роли.
        
        Args:
            user_id: Уникальный идентификатор пользователя
            role: Роль ассистента (стилист, косметолог, нутрициолог, дизайнер)
            user_input: Входящее сообщение пользователя
            previous_preferences: Предыдущие предпочтения пользователя (опционально)
            
        Returns:
            Словарь с результатами анализа:
            - success: Успешность операции
            - identified_needs: Определенные потребности
            - clarifying_questions: Уточняющие вопросы
            - preferences_updated: Были ли обновлены предпочтения
            - preferences: Обновленные предпочтения
        """
        try:
            # Создаем или используем существующие предпочтения
            preferences = previous_preferences
            if preferences is None:
                preferences = UserPreferences(user_id=user_id, role=role)
            
            # Формируем промпт в зависимости от роли
            if role == "стилист":
                prompt_template = """
                Проанализируй сообщение пользователя и определи следующие параметры:
                - бюджет (числовое значение)
                - предпочтения по стилю (повседневный, деловой, спортивный и т.д.)
                - размер одежды
                - предпочтения по цветам
                - сезон (весна, лето, осень, зима)
                - типы одежды (верхняя одежда, обувь, аксессуары и т.д.)
                - повод (работа, отдых, особое событие и т.д.)
                
                Если какой-то параметр не указан явно, оставь его пустым.
                
                Сформируй список уточняющих вопросов для параметров, которые не удалось определить.
                
                Ответ предоставь в формате JSON:
                {
                    "identified_needs": {
                        "budget": число или null,
                        "style_preferences": строка или null,
                        "size": строка или null,
                        "color_preferences": [список строк] или null,
                        "season": строка или null,
                        "garment_types": [список строк] или null,
                        "occasions": [список строк] или null
                    },
                    "clarifying_questions": [список строк с вопросами]
                }
                """
            elif role == "косметолог":
                prompt_template = """
                Проанализируй сообщение пользователя и определи следующие параметры:
                - бюджет (числовое значение)
                - тип кожи (сухая, жирная, комбинированная, нормальная)
                - проблемы с кожей (акне, морщины, пигментация и т.д.)
                - возрастной диапазон
                - аллергии
                - предпочитаемые бренды
                - предпочтение органической косметики (да/нет)
                
                Если какой-то параметр не указан явно, оставь его пустым.
                
                Сформируй список уточняющих вопросов для параметров, которые не удалось определить.
                
                Ответ предоставь в формате JSON:
                {
                    "identified_needs": {
                        "budget": число или null,
                        "skin_type": строка или null,
                        "skin_concerns": [список строк] или null,
                        "age_range": строка или null,
                        "allergies": [список строк] или null,
                        "preferred_brands": [список строк] или null,
                        "organic_only": true/false или null
                    },
                    "clarifying_questions": [список строк с вопросами]
                }
                """
            elif role == "нутрициолог":
                prompt_template = """
                Проанализируй сообщение пользователя и определи следующие параметры:
                - бюджет (числовое значение)
                - цель питания (похудение, набор массы, поддержание веса, здоровое питание)
                - диетические ограничения (вегетарианство, безглютеновая диета и т.д.)
                - вес (в кг)
                - рост (в см)
                - уровень активности (низкий, средний, высокий)
                - предпочтения по питанию
                - пищевые аллергии
                
                Если какой-то параметр не указан явно, оставь его пустым.
                
                Сформируй список уточняющих вопросов для параметров, которые не удалось определить.
                
                Ответ предоставь в формате JSON:
                {
                    "identified_needs": {
                        "budget": число или null,
                        "dietary_goal": строка или null,
                        "dietary_restrictions": [список строк] или null,
                        "weight": число или null,
                        "height": число или null,
                        "activity_level": строка или null,
                        "meal_preferences": объект или null,
                        "allergies_food": [список строк] или null
                    },
                    "clarifying_questions": [список строк с вопросами]
                }
                """
            elif role == "дизайнер":
                prompt_template = """
                Проанализируй сообщение пользователя и определи следующие параметры:
                - бюджет (числовое значение)
                - стиль интерьера (скандинавский, минимализм, классический и т.д.)
                - типы комнат (гостиная, спальня, кухня и т.д.)
                - размер помещения (в кв.м)
                - цветовая схема
                - имеющаяся мебель
                - планируется ли ремонт (да/нет)
                
                Если какой-то параметр не указан явно, оставь его пустым.
                
                Сформируй список уточняющих вопросов для параметров, которые не удалось определить.
                
                Ответ предоставь в формате JSON:
                {
                    "identified_needs": {
                        "budget": число или null,
                        "interior_style": строка или null,
                        "room_types": [список строк] или null,
                        "home_size": число или null,
                        "color_scheme": [список строк] или null,
                        "existing_furniture": объект или null,
                        "renovation_planned": true/false или null
                    },
                    "clarifying_questions": [список строк с вопросами]
                }
                """
            else:
                return {
                    "success": False,
                    "error": f"Неизвестная роль: {role}",
                    "clarifying_questions": [
                        "Какой у вас бюджет?",
                        "Какие у вас предпочтения?",
                        "Какая конкретная задача вас интересует?"
                    ],
                    "preferences_updated": False,
                    "preferences": preferences
                }
            
            # Формируем запрос к модели
            messages = [
                {"role": "system", "content": prompt_template},
                {"role": "user", "content": user_input}
            ]
            
            # Отправляем запрос к API
            if self.model_type == "openrouter":
                response_json = await self._call_openrouter_api_async(messages)
                response_text = response_json["choices"][0]["message"]["content"]
            else:
                response = await self.client.chat.completions.create(
                    model=self.model_name,
                    messages=messages,
                    max_tokens=self.max_tokens,
                    temperature=0.7
                )
                response_text = response.choices[0].message.content
            
            # Парсим JSON из ответа
            try:
                result = json.loads(response_text)
                identified_needs = result.get("identified_needs", {})
                clarifying_questions = result.get("clarifying_questions", [])
                
                # Обновляем предпочтения пользователя
                preferences_updated = False
                
                if role == "стилист":
                    if "budget" in identified_needs and identified_needs["budget"] is not None:
                        preferences.budget = float(identified_needs["budget"])
                        preferences_updated = True
                    if "style_preferences" in identified_needs and identified_needs["style_preferences"] is not None:
                        preferences.style_preferences = identified_needs["style_preferences"]
                        preferences_updated = True
                    if "size" in identified_needs and identified_needs["size"] is not None:
                        preferences.size = identified_needs["size"]
                        preferences_updated = True
                    if "color_preferences" in identified_needs and identified_needs["color_preferences"] is not None:
                        preferences.color_preferences = identified_needs["color_preferences"]
                        preferences_updated = True
                    if "season" in identified_needs and identified_needs["season"] is not None:
                        preferences.season = identified_needs["season"]
                        preferences_updated = True
                    if "garment_types" in identified_needs and identified_needs["garment_types"] is not None:
                        preferences.garment_types = identified_needs["garment_types"]
                        preferences_updated = True
                    if "occasions" in identified_needs and identified_needs["occasions"] is not None:
                        preferences.occasions = identified_needs["occasions"]
                        preferences_updated = True
                
                elif role == "косметолог":
                    if "budget" in identified_needs and identified_needs["budget"] is not None:
                        preferences.budget = float(identified_needs["budget"])
                        preferences_updated = True
                    if "skin_type" in identified_needs and identified_needs["skin_type"] is not None:
                        preferences.skin_type = identified_needs["skin_type"]
                        preferences_updated = True
                    if "skin_concerns" in identified_needs and identified_needs["skin_concerns"] is not None:
                        preferences.skin_concerns = identified_needs["skin_concerns"]
                        preferences_updated = True
                    if "age_range" in identified_needs and identified_needs["age_range"] is not None:
                        preferences.age_range = identified_needs["age_range"]
                        preferences_updated = True
                    if "allergies" in identified_needs and identified_needs["allergies"] is not None:
                        preferences.allergies = identified_needs["allergies"]
                        preferences_updated = True
                    if "preferred_brands" in identified_needs and identified_needs["preferred_brands"] is not None:
                        preferences.preferred_brands = identified_needs["preferred_brands"]
                        preferences_updated = True
                    if "organic_only" in identified_needs and identified_needs["organic_only"] is not None:
                        preferences.organic_only = identified_needs["organic_only"]
                        preferences_updated = True
                
                elif role == "нутрициолог":
                    if "budget" in identified_needs and identified_needs["budget"] is not None:
                        preferences.budget = float(identified_needs["budget"])
                        preferences_updated = True
                    if "dietary_goal" in identified_needs and identified_needs["dietary_goal"] is not None:
                        preferences.dietary_goal = identified_needs["dietary_goal"]
                        preferences_updated = True
                    if "dietary_restrictions" in identified_needs and identified_needs["dietary_restrictions"] is not None:
                        preferences.dietary_restrictions = identified_needs["dietary_restrictions"]
                        preferences_updated = True
                    if "weight" in identified_needs and identified_needs["weight"] is not None:
                        preferences.weight = float(identified_needs["weight"])
                        preferences_updated = True
                    if "height" in identified_needs and identified_needs["height"] is not None:
                        preferences.height = float(identified_needs["height"])
                        preferences_updated = True
                    if "activity_level" in identified_needs and identified_needs["activity_level"] is not None:
                        preferences.activity_level = identified_needs["activity_level"]
                        preferences_updated = True
                    if "meal_preferences" in identified_needs and identified_needs["meal_preferences"] is not None:
                        preferences.meal_preferences = identified_needs["meal_preferences"]
                        preferences_updated = True
                    if "allergies_food" in identified_needs and identified_needs["allergies_food"] is not None:
                        preferences.allergies_food = identified_needs["allergies_food"]
                        preferences_updated = True
                
                elif role == "дизайнер":
                    if "budget" in identified_needs and identified_needs["budget"] is not None:
                        preferences.budget = float(identified_needs["budget"])
                        preferences_updated = True
                    if "interior_style" in identified_needs and identified_needs["interior_style"] is not None:
                        preferences.interior_style = identified_needs["interior_style"]
                        preferences_updated = True
                    if "room_types" in identified_needs and identified_needs["room_types"] is not None:
                        preferences.room_types = identified_needs["room_types"]
                        preferences_updated = True
                    if "home_size" in identified_needs and identified_needs["home_size"] is not None:
                        preferences.home_size = float(identified_needs["home_size"])
                        preferences_updated = True
                    if "color_scheme" in identified_needs and identified_needs["color_scheme"] is not None:
                        preferences.color_scheme = identified_needs["color_scheme"]
                        preferences_updated = True
                    if "existing_furniture" in identified_needs and identified_needs["existing_furniture"] is not None:
                        preferences.existing_furniture = identified_needs["existing_furniture"]
                        preferences_updated = True
                    if "renovation_planned" in identified_needs and identified_needs["renovation_planned"] is not None:
                        preferences.renovation_planned = identified_needs["renovation_planned"]
                        preferences_updated = True
                
                # Обновляем время последнего обновления
                preferences.last_updated = datetime.utcnow()
                
                return {
                    "success": True,
                    "identified_needs": identified_needs,
                    "clarifying_questions": clarifying_questions,
                    "preferences_updated": preferences_updated,
                    "preferences": preferences
                }
            
            except json.JSONDecodeError as e:
                logger.error(f"Ошибка при парсинге JSON из ответа: {str(e)}")
                return {
                    "success": False,
                    "error": f"Ошибка при парсинге JSON: {str(e)}",
                    "clarifying_questions": [
                        "Какой у вас бюджет?",
                        "Какие у вас предпочтения?",
                        "Какая конкретная задача вас интересует?"
                    ],
                    "preferences_updated": False,
                    "preferences": preferences
                }
        
        except Exception as e:
            logger.error(f"Ошибка при определении потребностей пользователя: {str(e)}")
            return {
                "success": False,
                "error": f"Ошибка: {str(e)}",
                "clarifying_questions": [
                    "Какой у вас бюджет?",
                    "Какие у вас предпочтения?",
                    "Какая конкретная задача вас интересует?"
                ],
                "preferences_updated": False,
                "preferences": previous_preferences or UserPreferences(user_id=user_id, role=role)
            }
    
    def determine_user_needs(
        self,
        user_id: str,
        role: str,
        user_input: str,
        previous_preferences: Optional[UserPreferences] = None
    ) -> Dict[str, Any]:
        """
        Синхронная обертка для метода determine_user_needs_async.
        
        Args:
            user_id: Уникальный идентификатор пользователя
            role: Роль ассистента (стилист, косметолог, нутрициолог, дизайнер)
            user_input: Входящее сообщение пользователя
            previous_preferences: Предыдущие предпочтения пользователя (опционально)
            
        Returns:
            Словарь с результатами анализа
        """
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        # Вспомогательная функция для корректного закрытия сессии
        async def determine_and_close():
            try:
                return await self.determine_user_needs_async(user_id, role, user_input, previous_preferences)
            finally:
                await self.close()
        
        return loop.run_until_complete(determine_and_close())
    
    async def calculate_nutrition_async(
        self,
        products: List[Dict[str, Any]],
        quantities: List[float]
    ) -> Dict[str, Any]:
        """
        Асинхронно рассчитывает питательную ценность набора продуктов.
        
        Args:
            products: Список продуктов с их питательной ценностью
                Каждый продукт должен содержать следующие поля:
                - name: Название продукта
                - protein: Содержание белка (г/100г)
                - fat: Содержание жира (г/100г)
                - carbs: Содержание углеводов (г/100г)
                - calories: Калорийность (ккал/100г)
                - fiber: Содержание клетчатки (г/100г, опционально)
                - sugar: Содержание сахара (г/100г, опционально)
            quantities: Список количеств каждого продукта в граммах
            
        Returns:
            Словарь с результатами расчета:
            - success: Успешность операции
            - total_calories: Общая калорийность (ккал)
            - total_protein: Общее содержание белка (г)
            - total_fat: Общее содержание жира (г)
            - total_carbs: Общее содержание углеводов (г)
            - total_fiber: Общее содержание клетчатки (г, если доступно)
            - total_sugar: Общее содержание сахара (г, если доступно)
            - pfc_ratio: Соотношение БЖУ в процентах [белки%, жиры%, углеводы%]
            - recommendations: Рекомендации по оптимизации рациона
        """
        try:
            if len(products) != len(quantities):
                return {
                    "success": False,
                    "error": "Количество продуктов не соответствует количеству порций"
                }
            
            # Рассчитываем общую питательную ценность
            total_calories = 0
            total_protein = 0
            total_fat = 0
            total_carbs = 0
            total_fiber = 0
            total_sugar = 0
            
            # Рассчитываем питательную ценность для каждого продукта
            for product, quantity in zip(products, quantities):
                # Коэффициент для пересчета из 100г в фактическое количество
                factor = quantity / 100.0
                
                total_calories += product["calories"] * factor
                total_protein += product["protein"] * factor
                total_fat += product["fat"] * factor
                total_carbs += product["carbs"] * factor
                
                # Опциональные поля
                if "fiber" in product:
                    total_fiber += product["fiber"] * factor
                if "sugar" in product:
                    total_sugar += product["sugar"] * factor
            
            # Рассчитываем соотношение БЖУ в процентах
            total_energy = total_protein * 4 + total_fat * 9 + total_carbs * 4
            
            if total_energy > 0:
                protein_percent = round((total_protein * 4 / total_energy) * 100)
                fat_percent = round((total_fat * 9 / total_energy) * 100)
                carbs_percent = round((total_carbs * 4 / total_energy) * 100)
            else:
                protein_percent = 0
                fat_percent = 0
                carbs_percent = 0
            
            pfc_ratio = [protein_percent, fat_percent, carbs_percent]
            
            # Формируем рекомендации на основе расчетов
            prompt = f"""
            Проанализируй питательную ценность набора продуктов и дай рекомендации по его оптимизации:
            
            Общая калорийность: {total_calories:.1f} ккал
            Белки: {total_protein:.1f} г ({protein_percent}%)
            Жиры: {total_fat:.1f} г ({fat_percent}%)
            Углеводы: {total_carbs:.1f} г ({carbs_percent}%)
            Клетчатка: {total_fiber:.1f} г
            Сахар: {total_sugar:.1f} г
            
            Продукты:
            {', '.join([f"{p['name']} ({q}г)" for p, q in zip(products, quantities)])}
            
            Дай краткие рекомендации по оптимизации этого набора продуктов с точки зрения:
            1. Баланса БЖУ (оптимальное соотношение 30/30/40)
            2. Содержания клетчатки (рекомендуется 25-30г в день)
            3. Содержания сахара (рекомендуется не более 25г в день)
            4. Общей калорийности
            
            Предложи конкретные изменения, если необходимо.
            """
            
            # Отправляем запрос к API
            messages = [
                {"role": "system", "content": "Ты опытный нутрициолог, который дает точные рекомендации по питанию."},
                {"role": "user", "content": prompt}
            ]
            
            if self.model_type == "openrouter":
                response_json = await self._call_openrouter_api_async(messages)
                recommendations = response_json["choices"][0]["message"]["content"]
            else:
                response = await self.client.chat.completions.create(
                    model=self.model_name,
                    messages=messages,
                    max_tokens=self.max_tokens,
                    temperature=0.7
                )
                recommendations = response.choices[0].message.content
            
            # Формируем результат
            result = {
                "success": True,
                "total_calories": round(total_calories, 1),
                "total_protein": round(total_protein, 1),
                "total_fat": round(total_fat, 1),
                "total_carbs": round(total_carbs, 1),
                "total_fiber": round(total_fiber, 1),
                "total_sugar": round(total_sugar, 1),
                "pfc_ratio": pfc_ratio,
                "recommendations": recommendations
            }
            
            return result
        
        except Exception as e:
            logger.error(f"Ошибка при расчете питательной ценности: {str(e)}")
            return {
                "success": False,
                "error": f"Ошибка: {str(e)}"
            }
    
    def calculate_nutrition(
        self,
        products: List[Dict[str, Any]],
        quantities: List[float]
    ) -> Dict[str, Any]:
        """
        Синхронная обертка для метода calculate_nutrition_async.
        
        Args:
            products: Список продуктов с их питательной ценностью
            quantities: Список количеств каждого продукта в граммах
            
        Returns:
            Словарь с результатами расчета
        """
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        # Вспомогательная функция для корректного закрытия сессии
        async def calculate_and_close():
            try:
                return await self.calculate_nutrition_async(products, quantities)
            finally:
                await self.close()
        
        return loop.run_until_complete(calculate_and_close())
